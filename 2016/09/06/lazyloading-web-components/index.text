Title: Lazyloading Web Components
Date: 2016-09-06
Tags: programming, javascript, html, web-components, polymer
Summary: Convenience hacking: Web Components without imports.
Image: /2016/09/06/lazyloading-web-components/lazyload.gif
Gallery: 043
Mwc: 43

They say [good developers are lazy][lazy].  A tedious process is no match for a
lazy developer.  Below is an experiment in laziness.  It's a proof of concept
for using Web Components without having to manually import each one.

I'm not sure exactly what to call it.  It grazes the definitions of
lazyloading, autoloading, and dependency injection, so I went with the laziest
term.

Let's set the scene, and find out if it's a worthwhile developer convenience,
or ease-of-use gone mad...

## Scene 1: Maximize Simplicity

You are the author of "Wootstrap", a Bootstrap-like library of useful
components like navigation, buttons, and alerts.  Also like Bootstrap, your
components are distributed as HTML snippets for users to copy, paste, and
customize.

<video style="margin: 0 auto" poster="{attach}thumb.png" autoplay controls loop>
    <source src="{attach}bootstrap-paste.webm" />
    <source src="{attach}bootstrap-paste.mp4" />
</video>

To improve ease of use, you encapsulate all that HTML into a custom element:

<pre><code class="language-markup">{% filter escape %}
<ws-panel heading="I am a ws-panel">Some words.</ws-panel>
{% endfilter %}
</code></pre>

The essence of simplicity!  One more thing, browsers don't know what
`<ws-panel>` is, so your users must import it:

<pre><code class="language-markup">{% filter escape %}
<link rel="import" href="../bower_components/wootstrap/components/ws-panel.html">
{% endfilter %}
</code></pre>

One line, no big deal.  But as your users add and remove components from their
pages, managing imports becomes a finger-aching chore.

## Scene 2: Minimize Finger-Ache

Wouldn't it be cushy if the components were imported when you use them,
automatically?  Here's a working demo:

<div class="row">
    <div class="col-sm-4">
        <h3>The demo <small><a href="/static/043/index.html" target="_blank" rel="noopener noreferrer">open in tab</a></small></h3>
        <iframe frameborder=0 height="200" width="100%" src="/static/043/index.html"></iframe>
    </div>
    <div class="col-sm-8">
        <h3>The source</h3>
<pre data-line="3-4,7-11" style="font-size: 1.2rem"><code class="language-markup">{% filter escape %}
<html>
    <head>
        <script defer src="src/webcomponents.min.js"></script>
        <link rel="import" href="{attach}src/lazy-load/lazy-load.html">
    </head>
    <body>
        <lazy-load>
            <ws-panel heading="I am a ws-panel">Some words.</ws-panel>
            <ws-btn>I am ws-button</ws-btn>
            <ws-alert>I am a ws-alert</ws-alert>
        </lazy-load>
    </body>
</html>
{% endfilter %}
</code></pre>
    </div>
</div>

The demo only imports `lazy-load`, which in turn imports the
three `ws-` elements.  Let's look at how it works.

## Scene 3: Behind the Scenes

To lazyload, we need a list of all our component names and where to find them.
I created a small "registry" object for the demo.  In the real-world, this
object could be auto-generated by the component library's build system, or by
the build system of the user's app, including all available components.

<pre><code class="language-javascript">var LazyComponents = {
    names: 'ws-panel,ws-btn,ws-alert',
    paths: {
        'ws-panel' : './src/ws-components/ws-panel/ws-panel.html',
        'ws-btn'   : './src/ws-components/ws-btn/ws-btn.html',
        'ws-alert' : './src/ws-components/ws-alert/ws-alert.html',
    },
};
</code></pre>

First we have `names`, a comma-separated list of component names which doubles
as a selector.  It is passed into [querySelectorAll()][qsa] to find any
occurrences of our elements on the page.  Second is `paths`, a mapping from
each component's name to its HTML template file.

### The lazy-load element

Here's the Polymer definition for the `lazy-load` element:

<pre><code class="language-javascript">Polymer({

    is: 'lazy-load',

    attached: function lazyLoadAttached() {
        this.lazyLoad();
    },

    lazyLoad: function lazyLoad() {
        var els = this.querySelectorAll(LazyComponents.names);
        for (var i = 0; i &lt; els.length; ++i) {
            var name = els[i].nodeName.toLowerCase();
            this.importHref(LazyComponents.paths[name]);
        }
    },

});
</code></pre>

When `lazy-load` is [attached to the DOM][attached], it finds any children in
the `names` list and imports their HTML templates (using Polymer's handy
[importHref()][importhref] function).

Now any element in the registry object can be used without an explicit import.

## Tradeoffs

There are some things that may outweigh the convenience.

 - **Unvulcanized** - Lazy loading is the opposite of [Vulcanize][vulcanize].
   Vulcanize can still be used, but lazyloaded components won't be inlined.

 - **Delayed loading** - Explicit imports begin downloading before lazyloaded
   imports, since they don't have to wait for `lazy-load` to be attached to the
   DOM.

 - **Paths must be absolute** - Imports typically use relative paths, but
   lazyloaded paths are defined in only one spot, not per-page, so they must be
   absolute, *or* relative to `lazy-load.html`.

 - **Late to the party?** - Any custom elements added to the page after
   `lazyLoad()` has run won't be imported.  That didn't seem necessary for a
   proof of concept, but running `lazyLoad()` on each state change would be an
   easy solution.
 
 - **HTTP/2 Server Push?** - I haven't tested this, but I suspect lazyloaded
   components won't benefit from HTTP/2 Server Push.

I'm not sure yet which camp lazyloading will fall into: best practice, or
antipattern.  My hope is that developer tooling will be written that injects
imports as you code, rather than at runtime.

Thanks to Kyle Buchanan for pointers and corrections!

<img style="display: none !important;" src="{attach}lazyload.gif">

[vulcanize]: https://www.polymer-project.org/1.0/docs/tools/optimize-for-production
[qsa]: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll
[attached]: https://www.polymer-project.org/1.0/docs/devguide/registering-elements#lifecycle-callbacks
[importhref]: https://www.polymer-project.org/1.0/docs/devguide/instance-methods#imports-and-urls
[lazy]: http://threevirtues.com/
